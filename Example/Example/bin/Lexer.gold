using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
    lexer = createTransducer()
	 testLexer(lexer)
end
  
        

procedure testLexer(M:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
    	
	input = ""
		
		
		print "----------------------------"
		print "Enter one or more lines. End with a single line with $"
       print "If you want to stop testing, enter EXIT"
       string:=sc.nextLine() 



	while string != "EXIT" do
		
		
       
       while string.charAt(0) != '$' do
              input := input + string + " "
              string:=sc.nextLine()
       end
       
       result:=M.acceptsString(input)    
		tokenStream := M.getOutputString()
		
		print "The lexer did "+(result?"":"not ")+" accept the string."
		if result then print "Token Stream: "+ tokenStream end		

       print "----------------------------"
	
	   print "Enter one or more lines. End with a single line with $"
       print "If you want to stop testing, enter EXIT"
       string:=sc.nextLine() 

	end
print  "Good bye"
print  ""

end 

 


var names
  
function createTransducer():ITransducer begin
	// Lexer: reads a string with lower casae letters, digits, parenthesis, and spaces.
	// outputs a string of {'(',')','+','*','v','n'}
	
	states = {"I"}
	keywords := {"ROBOT_R", "VARS", "BEGIN", "assignVar", "move", "turn", "face", "put", "pick","moveDir","moveInDir","skip","facing","not", "END"}
	for each token∈keywords do
		states := states ∪ {token}
		sub := token.charAt(0) + λ
		for i:=1 to |token|-1 do
			states = states ∪ {sub}
			sub := sub + token.charAt(i)
		end
	end
	Q:= {"I","Id", "Num","Err"} ∪ states
	
	Σ:=('0'‥'9') ∪ ('a' ‥ 'z') ∪ {'(',')',' ',';','{','}','[',']',',','_',':'} ∪ ('A'‥'Z')
	Out := Σ ∪ ('A'‥'Z')∪ {'?','!'}
	q₀:="I"
	F:= {"I"}
	return 	GDeterministicTransducer(Q,Σ,Out,q₀,F,δ,g,h)
end

function δ(q,σ) begin
	keywords := {"ROBOT_R", "VARS", "BEGIN", "assignVar", "move", "turn", "face", "put", "pick","moveDir","moveInDir","skip","facing","not","END"}
	unary := {"move", "turn" , "face", "moveDir", "facing", "not"}
	set := Ø
	for each token∈keywords do
		set := set ∪ x(token)
	end
	if (q = "Err") then return "Err"
	elseif σ ∈ {'(',')',' ', '{','}','[',']', ';',','} then return "I"	
    elseif q="I" and σ∈{'R','V','B','a','m','t','f','p','s','n','E'} then return String.valueOf(σ)
	elseif q="I" and σ ∈ ('0' ‥ '9') then return "Num"
	elseif	q="Num" and σ ∈ ('0' ‥ '9') then return "Num"
	elseif	q="Num" and σ ∈ ('a' ‥ 'z')∪('A' ‥ 'Z') then return "Err"

	elseif q∈set and (q+σ)∈set then return q+σ
	elseif q∈set and (q+σ)∉set then return "Err"
    
    else  return "Id"
    end	
end 



function g(q) begin
	return λ
end

function h(q,σ) begin
	var s: String
	s := λ
	keywords := {"ROBOT_R", "VARS", "BEGIN", "assignVar", "move", "turn", "face", "put", "pick","moveDir","moveInDir","skip","facing","not","END"}

	if q ∉ {"Err"} and σ ∈ {'(',')',' ', ';','{','}','[',']',','} then
		if σ ∉ {' '} then  s=String.valueOf(σ) end
		if q=="I" then return s
    	elseif q=="ROBOT_R" then return "RBT"+s+";" 
   		elseif q=="VARS" then return "VRS"+s+":"
   		elseif q=="BEGIN" then return "BG"+s+";"
   		elseif q=="assignVar" then return "AV"+s
   		elseif q=="move" then return "m"+s
   		elseif q=="turn" then return "t"+s
   		elseif q=="face" then return "f"+s
   		elseif q=="put" then return "pt"+s
   		elseif q=="pick" then return "pk"+s
   		elseif q=="moveDir" then return "MD"+s
   		elseif q=="moveInDir" then return "MID"+s
   		elseif q=="skip" then return "sk"+s
   		elseif q=="facing" then return "f?"+s
   		elseif q=="not" then return "!"+s
   		elseif q=="END" then return "E"+s
		
		elseif q=="Num" then return "n"+s
		else return "v"+s
 		end
	else return  λ
	end
	return λ
end

function x(token) begin
	states :=Ø
	states := states ∪ {token}
	sub := token.charAt(0) + λ
	for i:=1 to |token|-1 do
		states = states ∪ {sub}
		sub := sub + token.charAt(i)
	end
	return states
end